!OPTIONS XOPT(NOEVAL)
SUBROUTINE WRAP_ACDRAG (YDCST, YDML_PHY_MF,KIDIA,KFDIA,KLON,KTDIA,KLEV,&
 !-----------------------------------------------------------------------
 ! - INPUT  2D .
 & PAPRS,PAPRSF,PDELP,PNBVNO,PRDELP,PU,PV,&
 ! - INPUT  1D .
 & PRCORI,PGETRL,PGWDCS,PVRLAN,PVRLDI,&
 ! - OUTPUT 2D .
 & PSTRDU,PSTRDV,PRAPTRAJ)

USE YOMACDRAG !contains the buffers in which data is copied
USE YOMDATA !contains SAVE methods

! util_xxxxx_mod are generated by a scrip, see presentation
! example :
!fxtran-acdc/master/bin/fxtran-f90 --dryrun --method methods --methods save,load -- f90 -c model_physics_mf_type.F90
USE UTIL_TCST_MOD !contains save method for TCST type
USE UTIL_MODEL_PHYSICS_MF_TYPE_MOD !contains save method for MODEL_PHYSICS_MF_TYPE


USE MODEL_PHYSICS_MF_MOD , ONLY : MODEL_PHYSICS_MF_TYPE
USE PARKIND1  ,ONLY : JPIM     ,JPRB    ,JPRD

USE YOMCST   , ONLY : TCST

!-----------------------------------------------------------------------

IMPLICIT NONE

TYPE(TCST),        INTENT(IN)    :: YDCST
TYPE(MODEL_PHYSICS_MF_TYPE),INTENT(IN):: YDML_PHY_MF
INTEGER(KIND=JPIM),INTENT(IN)    :: KLON 
INTEGER(KIND=JPIM),INTENT(IN)    :: KLEV 
INTEGER(KIND=JPIM),INTENT(IN)    :: KIDIA 
INTEGER(KIND=JPIM),INTENT(IN)    :: KFDIA 
INTEGER(KIND=JPIM),INTENT(IN)    :: KTDIA 
REAL(KIND=JPRB)   ,INTENT(IN)    :: PAPRS(KLON,0:KLEV) 
REAL(KIND=JPRB)   ,INTENT(IN)    :: PAPRSF(KLON,KLEV) 
REAL(KIND=JPRB)   ,INTENT(IN)    :: PDELP(KLON,KLEV) 
REAL(KIND=JPRB)   ,INTENT(IN)    :: PNBVNO(KLON,0:KLEV) 
REAL(KIND=JPRB)   ,INTENT(IN)    :: PRDELP(KLON,KLEV) 
REAL(KIND=JPRB)   ,INTENT(IN)    :: PU(KLON,KLEV) 
REAL(KIND=JPRB)   ,INTENT(IN)    :: PV(KLON,KLEV) 
REAL(KIND=JPRB)   ,INTENT(IN)    :: PRCORI(KLON) 
REAL(KIND=JPRB)   ,INTENT(IN)    :: PGETRL(KLON) 
REAL(KIND=JPRB)   ,INTENT(IN)    :: PGWDCS(KLON) 
REAL(KIND=JPRB)   ,INTENT(IN)    :: PVRLAN(KLON) 
REAL(KIND=JPRB)   ,INTENT(IN)    :: PVRLDI(KLON) 
REAL(KIND=JPRB)   ,INTENT(OUT)   :: PSTRDU(KLON,0:KLEV) 
REAL(KIND=JPRB)   ,INTENT(OUT)   :: PSTRDV(KLON,0:KLEV) 
REAL(KIND=JPRB)   ,INTENT(OUT)   :: PRAPTRAJ(KLON,0:KLEV) 

INTEGER :: ILUN

!-----------------------------------------------------------------------

REAL(KIND=JPRB) :: ZIPOI(KLON,KLEV),ZNFNO(KLON,0:KLEV),ZPOID(KLON,KLEV)&
 & ,ZRAPP(KLON,0:KLEV),ZU(KLON,KLEV),ZV(KLON,KLEV)&
 & ,ZWGHT(KLON,0:KLEV),ZDS1(KLON),ZDS2(KLON),ZFACS(KLON)&
 & ,ZOBST(KLON),ZPR1(KLON),ZPR2(KLON),ZREF(KLON),ZSTM(KLON)&
 & ,ZSTS(KLON),ZSTUS(KLON),ZSTVS(KLON),ZSUM(KLON)&
 & ,ZSUMD(KLON),ZSUMF(KLON),ZSUMU(KLON),ZSUMV(KLON)&
 & ,ZSUSR(KLON),ZTST1(KLON),ZTST2(KLON),ZUSR(KLON)&
 & ,ZUSUR(KLON),ZVSUR(KLON),ZWGHTK(KLON),ZZAA(KLON),ZZBB(KLON)&
 & ,ZZCR(KLON),ZZCU(KLON),ZZCV(KLON)  
 
INTEGER(KIND=JPIM) :: ITOP, JLEV, JLON

REAL(KIND=JPRB) :: ZA, ZALP1, ZALP2, ZALPHA, ZALTI, ZARGLI, ZAUSR,&
 & ZBETA, ZD, ZDEL1, ZDEL2, ZDIFSR, ZDIFSU, ZDIFSV,&
 & ZDU, ZDV, ZDX, ZEPS1, ZEPS2, ZEPS3, ZEPS4,&
 & ZEPS5, ZEPS6, ZFORCA, ZFORCB, ZFORCL, ZGDT,&
 & ZGDTI, ZLIFT, ZLIFTG, ZPBL, ZPBLF, ZPRRAP, ZRZ,&
 & ZTEMPF(KLON), ZTEST, ZTUNE, ZUSTAR, ZVSTAR, ZX, ZZPR, ZRZR
REAL(KIND=JPRB) :: ZCOS(KLON)

!-----------------------------------------------------------------------
ASSOCIATE(HOBST=>YDML_PHY_MF%YRPHY0%HOBST, GWDBC=>YDML_PHY_MF%YRPHY0%GWDBC, GWDCD=>YDML_PHY_MF%YRPHY0%GWDCD, &
 & GWDLT=>YDML_PHY_MF%YRPHY0%GWDLT, GWDVALI=>YDML_PHY_MF%YRPHY0%GWDVALI, GWDPROF=>YDML_PHY_MF%YRPHY0%GWDPROF, &
 & GWDAMP=>YDML_PHY_MF%YRPHY0%GWDAMP, GWDSE=>YDML_PHY_MF%YRPHY0%GWDSE, &
 & TSPHY=>YDML_PHY_MF%YRPHY2%TSPHY, &
 & RG=>YDCST%RG, RPI=>YDCST%RPI, &
 & NPHYREP=>YDML_PHY_MF%YRPHY%NPHYREP, LNEWD=>YDML_PHY_MF%YRPHY%LNEWD, LGLT=>YDML_PHY_MF%YRPHY%LGLT)

! 1) allocate data if not already allocated
IF (.NOT. LLALLOCATED) THEN

!$OMP CRITICAL

IF (.NOT. LLALLOCATED) THEN

  ALLOCATE (PSTRDU_OUT(KLON, 0:KLEV, IGPBLKS))
  ALLOCATE (PSTRDV_OUT(KLON, 0:KLEV, IGPBLKS))
  ALLOCATE (PRAPTRAJ_OUT(KLON, 0:KLEV, IGPBLKS))
  !======================
  ALLOCATE (ZZAPRS(KLON, 0:KLEV, IGPBLKS))
  ALLOCATE (ZZAPRSF(KLON, KLEV, IGPBLKS))
  ALLOCATE (ZZDELP(KLON, KLEV, IGPBLKS))
  ALLOCATE (ZZNBVNO(KLON, 0:KLEV, IGPBLKS))
  ALLOCATE (ZZRDELP(KLON, KLEV, IGPBLKS))
  ALLOCATE (ZZU(KLON, KLEV, IGPBLKS))
  ALLOCATE (ZZV(KLON, KLEV, IGPBLKS))
  ALLOCATE (ZZRCORI(KLON, IGPBLKS))
  ALLOCATE (ZZGETRL(KLON, IGPBLKS))
  ALLOCATE (ZZGWDCS(KLON, IGPBLKS))
  ALLOCATE (ZZVRLAN(KLON, IGPBLKS))
  ALLOCATE (ZZVRLDI(KLON, IGPBLKS))
  ALLOCATE (ZZSTRDU(KLON, 0:KLEV, IGPBLKS))
  ALLOCATE (ZZSTRDV(KLON, 0:KLEV, IGPBLKS))
  ALLOCATE (ZZRAPTRAJ(KLON, 0:KLEV, IGPBLKS))
  
  LLALLOCATED = .TRUE.
ENDIF 

!$OMP END CRITICAL

ENDIF

! 2) Copy input data 

IF (LLSAVE .AND. (JBLK == 1)) THEN
ILUN = 77
OPEN (ILUN, FILE='ACDRAG.CONST.dat', FORM='UNFORMATTED')

! For the first block, we save derived types and integers

CALL ACDC_SAVE(YDCST, ILUN)
CALL ACDC_SAVE(YDML_PHY_MF, ILUN)
CALL SAVE(KLON, ILUN)
CALL SAVE(KLEV, ILUN)
CALL SAVE(KIDIA, ILUN)
CALL SAVE(KFDIA, ILUN)
CALL SAVE(KTDIA, ILUN)
CALL SAVE(ITOP, ILUN)
CALL SAVE(JLEV, ILUN)
CALL SAVE(JLON, ILUN)

CLOSE(ILUN)

ENDIF

! copy the data of the current block

ZZAPRS(:, :, JBLK) = PAPRS(:, :)
ZZAPRSF(:, :, JBLK) = PAPRSF(:, :)
ZZDELP(:, :, JBLK) = PDELP(:, :)
ZZNBVNO(:, :, JBLK) = PNBVNO(:, :)
ZZRDELP(:, :, JBLK) = PRDELP(:, :)
ZZU(:, :, JBLK) = PU(:, :)
ZZV(:, :, JBLK) = PV(:, :)
ZZRCORI(:, JBLK) = PRCORI(:)
ZZGETRL(:, JBLK) = PGETRL(:)
ZZGWDCS(:, JBLK) = PGWDCS(:)
ZZVRLAN(:, JBLK) = PVRLAN(:)
ZZVRLDI(:, JBLK) = PVRLDI(:)
ZZSTRDU(:, :, JBLK) = PSTRDU(:, :)
ZZSTRDV(:, :, JBLK) = PSTRDV(:, :)
ZZRAPTRAJ(:, :, JBLK) = PRAPTRAJ(:, :)

! 3) call ACDRAG
CALL ACDRAG (YDCST, YDML_PHY_MF,KIDIA,KFDIA,KLON,KTDIA,KLEV,&
 & PAPRS,PAPRSF,PDELP,PNBVNO,PRDELP,PU,PV,&
 & PRCORI,PGETRL,PGWDCS,PVRLAN,PVRLDI,&
 & PSTRDU,PSTRDV,PRAPTRAJ)

! 4) copy output data
PSTRDU_OUT(:, :, JBLK) = PSTRDU(:, :)
PSTRDV_OUT(:, :, JBLK) = PSTRDV(:, :)
PRAPTRAJ_OUT(:, :, JBLK) = PRAPTRAJ(:, :)

END ASSOCIATE
END SUBROUTINE WRAP_ACDRAG
